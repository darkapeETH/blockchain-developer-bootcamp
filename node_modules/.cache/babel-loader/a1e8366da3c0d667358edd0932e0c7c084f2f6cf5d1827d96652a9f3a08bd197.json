{"ast":null,"code":"import { ethers } from 'ethers';\nimport TOKEN_ABI from '../ABIs/Token.json';\nimport EXCHANGE_ABI from '../ABIs/Exchange.json';\nexport const loadProvider = dispatch => {\n  const connection = new ethers.providers.Web3Provider(window.ethereum);\n  dispatch({\n    type: 'PROVIDER_LOADED',\n    connection\n  });\n  return connection;\n};\nexport const loadNetwork = async (provider, dispatch) => {\n  const {\n    chainId\n  } = await provider.getNetwork();\n  dispatch({\n    type: 'NETWORK_LOADED',\n    chainId\n  });\n  return chainId;\n};\nexport const loadAccount = async (provider, dispatch) => {\n  const accounts = await window.ethereum.request({\n    method: 'eth_requestAccounts'\n  });\n  const account = ethers.utils.getAddress(accounts[0]);\n  dispatch({\n    type: 'ACCOUNT_LOADED',\n    account\n  });\n  let balance = await provider.getBalance(account);\n  balance = ethers.utils.formatEther(balance);\n  dispatch({\n    type: 'ETHER_BALANCE_LOADED',\n    balance\n  });\n  return account;\n};\nexport const loadTokens = async (provider, addresses, dispatch) => {\n  let token, symbol;\n  token = new ethers.Contract(addresses[0], TOKEN_ABI, provider);\n  symbol = await token.symbol();\n  dispatch({\n    type: 'TOKEN_1_LOADED',\n    token,\n    symbol\n  });\n  token = new ethers.Contract(addresses[1], TOKEN_ABI, provider);\n  symbol = await token.symbol();\n  dispatch({\n    type: 'TOKEN_2_LOADED',\n    token,\n    symbol\n  });\n  return token;\n};\nexport const loadExchange = async (provider, address, dispatch) => {\n  const exchange = new ethers.Contract(address, EXCHANGE_ABI, provider);\n  dispatch({\n    type: 'EXCHANGE_LOADED',\n    exchange\n  });\n  return exchange;\n};\nexport const subscribeToEvents = (exchange, dispatch) => {\n  exchange.on('Deposit', (token, user, amount, balance, event) => {\n    dispatch({\n      type: 'TRANSFER_SUCCESS',\n      event\n    });\n  });\n  exchange.on('Withdraw', (token, user, amount, balance, event) => {\n    dispatch({\n      type: 'TRANSFER_SUCCESS',\n      event\n    });\n  });\n  exchange.on('Order', (id, user, tokenGet, amountGet, tokenGive, amountGive, timestamp, event) => {\n    const order = event.args;\n    dispatch({\n      type: 'NEW_ORDER_SUCCESS',\n      order,\n      event\n    });\n  });\n};\nexport const loadBalances = async (exchange, tokens, account, dispatch) => {\n  let balance = ethers.utils.formatEther(await tokens[0].balanceOf(account), 18);\n  dispatch({\n    type: 'TOKEN_1_BALANCE_LOADED',\n    balance\n  });\n  balance = ethers.utils.formatEther(await exchange.balanceOf(tokens[0].address, account), 18);\n  dispatch({\n    type: 'EXCHANGE_TOKEN_1_BALANCE_LOADED',\n    balance\n  });\n  balance = ethers.utils.formatEther(await tokens[1].balanceOf(account), 18);\n  dispatch({\n    type: 'TOKEN_2_BALANCE_LOADED',\n    balance\n  });\n  balance = ethers.utils.formatEther(await exchange.balanceOf(tokens[1].address, account), 18);\n  dispatch({\n    type: 'EXCHANGE_TOKEN_2_BALANCE_LOADED',\n    balance\n  });\n};\nexport const transferTokens = async (provider, exchange, transferType, token, amount, dispatch) => {\n  let transaction;\n  dispatch({\n    type: 'TRANSFER_REQUEST'\n  });\n  try {\n    const signer = await provider.getSigner();\n    const amountToTransfer = ethers.utils.parseUnits(amount.toString(), 18);\n    if (transferType === 'Deposit') {\n      transaction = await token.connect(signer).approve(exchange.address, amountToTransfer);\n      await transaction.wait();\n      transaction = await exchange.connect(signer).depositToken(token.address, amountToTransfer);\n      await transaction.wait();\n    } else {\n      transaction = await token.connect(signer).approve(exchange.address, amountToTransfer);\n      await transaction.wait();\n      transaction = await exchange.connect(signer).withdrawToken(token.address, amountToTransfer);\n      await transaction.wait();\n    }\n  } catch (error) {\n    dispatch({\n      type: 'TRANSFER_FAIL'\n    });\n  }\n};\nexport const makeBuyOrder = async (provider, exchange, tokens, order, dispatch) => {\n  const tokenGet = tokens[0].address;\n  const amountGet = ethers.utils.parseUnits(order.amount, 18);\n  const tokenGive = tokens[1].address;\n  const amountGive = ethers.utils.parseUnits((order.amount * order.price).toString(), 18);\n  dispatch({\n    type: 'NEW_ORDER_REQUEST'\n  });\n  try {\n    const signer = await provider.getSigner();\n    const transaction = await exchange.connect(signer).makeOrder(tokenGet, amountGet, tokenGive, amountGive);\n    await transaction.wait();\n  } catch (error) {\n    dispatch({\n      type: 'NEW_ORDER_FAIL'\n    });\n  }\n};\nexport const makeSellOrder = async (provider, exchange, tokens, order, dispatch) => {\n  const tokenGet = tokens[1].address;\n  const amountGet = ethers.utils.parseUnits((order.amount * order.price).toString(), 18);\n  const tokenGive = tokens[0].address;\n  const amountGive = ethers.utils.parseUnits(order.amount, 18);\n  dispatch({\n    type: 'NEW_ORDER_REQUEST'\n  });\n  try {\n    const signer = await provider.getSigner();\n    const transaction = await exchange.connect(signer).makeOrder(tokenGet, amountGet, tokenGive, amountGive);\n    await transaction.wait();\n  } catch (error) {\n    dispatch({\n      type: 'NEW_ORDER_FAIL'\n    });\n  }\n};\n\n//Load all orders\nexport const loadAllOrders = async (provider, exchange, dispatch) => {\n  const block = await provider.getBlockNumber();\n\n  //Fetch cancelled orders\n  const cancellStream = await exchange.queryFilter('Order', 0, block);\n  const cancelledOrders = cancellStream.map(event => event.args);\n  dispatch({\n    type: 'CANCELLED_ORDERS_LOADED',\n    cancelledOrders\n  });\n\n  //Fetch filled orders\n  const tradeStream = await exchange.queryFilter('Order', 0, block);\n  const filledOrders = tradeStream.map(event => event.args);\n  dispatch({\n    type: 'FILLED_ORDERS_LOADED',\n    filledOrders\n  });\n\n  //Fetch all orders\n  const orderStream = await exchange.queryFilter('Order', 0, block);\n  const allOrders = orderStream.map(event => event.args);\n  dispatch({\n    type: 'ALL_ORDERS_LOADED',\n    allOrders\n  });\n};","map":{"version":3,"names":["ethers","TOKEN_ABI","EXCHANGE_ABI","loadProvider","dispatch","connection","providers","Web3Provider","window","ethereum","type","loadNetwork","provider","chainId","getNetwork","loadAccount","accounts","request","method","account","utils","getAddress","balance","getBalance","formatEther","loadTokens","addresses","token","symbol","Contract","loadExchange","address","exchange","subscribeToEvents","on","user","amount","event","id","tokenGet","amountGet","tokenGive","amountGive","timestamp","order","args","loadBalances","tokens","balanceOf","transferTokens","transferType","transaction","signer","getSigner","amountToTransfer","parseUnits","toString","connect","approve","wait","depositToken","withdrawToken","error","makeBuyOrder","price","makeOrder","makeSellOrder","loadAllOrders","block","getBlockNumber","cancellStream","queryFilter","cancelledOrders","map","tradeStream","filledOrders","orderStream","allOrders"],"sources":["/mnt/c/pr0/blockchain-developer-bootcamp/src/store/interactions.js"],"sourcesContent":["import { ethers } from 'ethers'\r\nimport TOKEN_ABI from '../ABIs/Token.json';\r\nimport EXCHANGE_ABI from '../ABIs/Exchange.json';\r\n\r\nexport const loadProvider = (dispatch) => {\r\n  const connection = new ethers.providers.Web3Provider(window.ethereum)\r\n  dispatch({ type: 'PROVIDER_LOADED', connection })\r\n\r\n  return connection\r\n}\r\n\r\nexport const loadNetwork = async (provider, dispatch) => {\r\n  const { chainId } = await provider.getNetwork()\r\n  dispatch({ type: 'NETWORK_LOADED', chainId })\r\n\r\n  return chainId\r\n}\r\n\r\nexport const loadAccount = async (provider, dispatch) => {\r\n  const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' })\r\n  const account = ethers.utils.getAddress(accounts[0])\r\n\r\n  dispatch({ type: 'ACCOUNT_LOADED', account })\r\n\r\n  let balance = await provider.getBalance(account)\r\n  balance = ethers.utils.formatEther(balance)\r\n\r\n  dispatch({ type: 'ETHER_BALANCE_LOADED', balance })\r\n\r\n  return account\r\n}\r\n\r\nexport const loadTokens = async (provider, addresses, dispatch) => {\r\n  let token, symbol\r\n\r\n  token = new ethers.Contract(addresses[0], TOKEN_ABI, provider)\r\n  symbol = await token.symbol()\r\n  dispatch({ type: 'TOKEN_1_LOADED', token, symbol })\r\n\r\n  token = new ethers.Contract(addresses[1], TOKEN_ABI, provider)\r\n  symbol = await token.symbol()\r\n  dispatch({ type: 'TOKEN_2_LOADED', token, symbol })\r\n\r\n  return token\r\n}\r\n\r\nexport const loadExchange = async (provider, address, dispatch) => {\r\n  const exchange = new ethers.Contract(address, EXCHANGE_ABI, provider);\r\n  dispatch({ type: 'EXCHANGE_LOADED', exchange })\r\n\r\n  return exchange\r\n}\r\n\r\nexport const subscribeToEvents = (exchange, dispatch) => {\r\n  exchange.on('Deposit', (token, user, amount, balance, event) => {\r\n    dispatch({ type: 'TRANSFER_SUCCESS', event })\r\n  })\r\n  exchange.on('Withdraw', (token, user, amount, balance, event) => {\r\n    dispatch({ type: 'TRANSFER_SUCCESS', event })\r\n  })\r\n  exchange.on('Order', (id, user, tokenGet, amountGet, tokenGive, amountGive, timestamp, event) => {\r\n    const order = event.args\r\n    dispatch({ type: 'NEW_ORDER_SUCCESS', order, event })\r\n  })\r\n}\r\n\r\nexport const loadBalances = async (exchange, tokens, account, dispatch) => {\r\n\r\n  let balance = ethers.utils.formatEther(await tokens[0].balanceOf(account),18)\r\n  dispatch({ type: 'TOKEN_1_BALANCE_LOADED', balance })\r\n\r\n  balance = ethers.utils.formatEther(await exchange.balanceOf(tokens[0].address, account),18)\r\n  dispatch({ type: 'EXCHANGE_TOKEN_1_BALANCE_LOADED', balance})\r\n\r\n  balance = ethers.utils.formatEther(await tokens[1].balanceOf(account),18)\r\n  dispatch({ type: 'TOKEN_2_BALANCE_LOADED', balance })\r\n\r\n  balance = ethers.utils.formatEther(await exchange.balanceOf(tokens[1].address, account),18)\r\n  dispatch({ type: 'EXCHANGE_TOKEN_2_BALANCE_LOADED', balance})\r\n}\r\n\r\nexport const transferTokens = async (provider, exchange, transferType, token, amount, dispatch) => {\r\n  let transaction\r\n  dispatch({type: 'TRANSFER_REQUEST'})\r\n\r\n  try {\r\n    const signer = await provider.getSigner()\r\n    const amountToTransfer = ethers.utils.parseUnits(amount.toString(),18)\r\n\r\n    if (transferType === 'Deposit') {\r\n      transaction = await token.connect(signer).approve(exchange.address, amountToTransfer)\r\n      await transaction.wait()\r\n      transaction = await exchange.connect(signer).depositToken(token.address, amountToTransfer)\r\n      await transaction.wait()      \r\n    } else {\r\n      transaction = await token.connect(signer).approve(exchange.address, amountToTransfer)\r\n      await transaction.wait()\r\n      transaction = await exchange.connect(signer).withdrawToken(token.address, amountToTransfer)\r\n      await transaction.wait()\r\n    }\r\n  } catch(error) {\r\n    dispatch({ type: 'TRANSFER_FAIL'})\r\n  }\r\n\r\n}\r\n\r\nexport const makeBuyOrder = async (provider, exchange, tokens, order, dispatch) => {\r\n\r\n  const tokenGet = tokens[0].address\r\n  const amountGet = ethers.utils.parseUnits(order.amount,18)\r\n  const tokenGive = tokens[1].address  \r\n  const amountGive = ethers.utils.parseUnits((order.amount * order.price).toString(),18)\r\n  dispatch({type: 'NEW_ORDER_REQUEST' })\r\n\r\n  try {\r\n  const signer = await provider.getSigner()\r\n  const transaction = await exchange.connect(signer).makeOrder(tokenGet, amountGet, tokenGive, amountGive)\r\n  await transaction.wait()\r\n  } catch (error) {\r\n    dispatch({type: 'NEW_ORDER_FAIL' })\r\n  }\r\n}\r\n\r\nexport const makeSellOrder = async (provider, exchange, tokens, order, dispatch) => {\r\n\r\n  const tokenGet = tokens[1].address\r\n  const amountGet = ethers.utils.parseUnits((order.amount * order.price).toString(),18)\r\n  const tokenGive = tokens[0].address  \r\n  const amountGive = ethers.utils.parseUnits(order.amount,18)\r\n  dispatch({type: 'NEW_ORDER_REQUEST' })\r\n\r\n  try {\r\n  const signer = await provider.getSigner()\r\n  const transaction = await exchange.connect(signer).makeOrder(tokenGet, amountGet, tokenGive, amountGive)\r\n  await transaction.wait()\r\n  } catch (error) {\r\n    dispatch({type: 'NEW_ORDER_FAIL' })\r\n  }\r\n}\r\n\r\n//Load all orders\r\nexport const loadAllOrders = async (provider, exchange, dispatch) => {\r\n  const block = await provider.getBlockNumber()\r\n\r\n  //Fetch cancelled orders\r\n  const cancellStream = await exchange.queryFilter('Order', 0, block)\r\n  const cancelledOrders = cancellStream.map(event => event.args)\r\n\r\n  dispatch({type: 'CANCELLED_ORDERS_LOADED', cancelledOrders })\r\n\r\n\r\n  //Fetch filled orders\r\n  const tradeStream = await exchange.queryFilter('Order', 0, block)\r\n  const filledOrders = tradeStream.map(event => event.args)\r\n\r\n  dispatch({type: 'FILLED_ORDERS_LOADED', filledOrders })\r\n\r\n\r\n  //Fetch all orders\r\n  const orderStream = await exchange.queryFilter('Order', 0, block)\r\n  const allOrders = orderStream.map(event => event.args)\r\n\r\n  dispatch({type: 'ALL_ORDERS_LOADED', allOrders })\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}